package condi;
/**
 * 
 * 这些方法属于Object,而不属于Thread。
 * 每一个对象除了有一个锁之外，还有一个等待队列（wait set），当一个对象刚创建的时候，他的等待队列是空的。
 * 
 * wait方法呢，是在当前线程锁住对象的锁后，才调用该对象的wait方法的。即在同步代码块中或者同步方法中进行调用的。
 * 调用后，该对象的等待队列中就有了一个所在线程，那个线程进入等待状态，
 * 此时，只有该对象调用notify方法，才可以把那个线程从队列里面拿出来，使这个线程成为可运行线程。 
 * notifyAll方法就是把该对象等待队列里面的所有线程唤醒，成为可运行线程。
 *
 *
 *wait():
等待对象的同步锁,需要获得该对象的同步锁才可以调用这个方法,否则编译可以通过，但运行时会收到一个异常：IllegalMonitorStateException。
调用任意对象的 wait() 方法导致该线程阻塞，该线程不可继续执行，并且该对象上的锁被释放。
notify():
唤醒在等待该对象同步锁的线程(只唤醒一个,如果有多个在等待),注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
调用任意对象的notify()方法则导致因调用该对象的 wait()方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。
notifyAll():
唤醒所有等待的线程,注意唤醒的是notify之前wait的线程,对于notify之后的wait线程是没有效果的
 */
public class WaitAndNotify {
	public static void main(String[] args) {
		
	}
}
